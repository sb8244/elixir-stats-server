# StatsServer

**This project is under active development and is not ready to be run in production**

A deployable service that acts as a broker between a JS frontend and many Elixir service backends (many nodes). The frontend can send a request throughout the system like "fetch system stats" and get all of the stats for current nodes. Or maybe "fetch 100 highest processes per node". This could be done for an application (cluster), node (single), or all (clusters)

## Elixir Node Side
Connects to the central broker via a persistent websocket. always listening for known commands and can respond in certain formats like "stats list" or "plaintext". Custom commands can be added per application.

## Security
AES encryption on JS and Elixir nodes. The websocket broker has no idea what messages / data is being sent over the wire.

## Reason
No APM right now allows things like "give me a process list". Collecting this across many Elixir Nodes is very cumbersome and can take minutes or longer. This might also be intensive work that you only want to run at your command ,rather than automated.

## Flow

- [x] JS client sends encrypted command (client: [application_name, encrypted_command, command_id]) to client websocket
- [x] Client websocket sends a message to the server channel topic (server:application_id: [command_id, encrypted_command])
- [x] Server websocket listens to the channel topic to broadcast out to the connected socket
- [x] Server channel is processed by each connected server, sends data back over the server channel
- [x] Data received on server channel is sent to client (client: [command_id, encrypted_response, application_name, server_id])

The command_id is randomly generated by the client and acts as an identifier for a request of information throughout the system.

## TODO

- [x] Working end to end flow
- [x] Encryption throughout flow
- [x] JS test flow
- [x] Elixir flow
- [x] Presence setup on server
- [x] Presence sending to the client
- [x] Run command on a single application node
- [x] Frontend can send stat commands and view output
- [x] Frontend is nice to use
  - [x] Multiple colors per server (how to do this with many servers)
  - [x] Single time range selection across all Charts
  - [post MVP] With time range selection that includes the last data point & a new data point, update the timerange end
        to the new data point, don't change beginning
  - [x] Differentiate between servers on the scatter plots
  - [x] Color code server names based on their chart color (same color for server always)
  - [post MVP] Show stats from selected servers only (globally applies)
  - [post MVP] Default to a maximum rolling 5 minute window for time range, [max(range.begin, 5 min ago), range.end]
  - [x] Show series avg, max, min + selected value for all series below each chart
  - [x] Clear all chart data
  - [post MVP] Show selected time range + clear button
  - [x] Display process lists per server
  - [x] Clear process list data
  - [x] Separate charts and other types of responses
  - [x] Design decent enough to use
- [x] Package up MockClient into a library that can be deployed to other servers
- [ ] Installation instructions
- [ ] Well defined response formats (graphing, text, etc)
- [ ] Extendable / custom commands
- [x] Docker deployment
- [ ] deploy to heroku button (is this still a thing?)

## Problem List

- [ ] Performance with lots of points is bad with lots of graphs (better without EventMarker)
- [ ] react-event-observer + context isn't a great way to manage state (redux swap out? high effort)

## Execution

A docker container is provided that can run the stats server. This is chosen for
consistency in deployment and being able to deploy on Heroku or kubernetes easily.

## Testing out

1. Run server with mix phx.server
2. Visit localhost:4000
3. Select "Mock Server" and send commands to it
