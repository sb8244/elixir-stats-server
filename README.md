# StatsServer

A deployable service that acts as a broker between a JS frontend and many Elixir service backends (many nodes). The frontend can send a request throughout the system like "fetch system stats" and get all of the stats for current nodes. Or maybe "fetch 100 highest processes per node". This could be done for an application (cluster), node (single), or all (clusters)

*Elixir Node Side*
Connects to the central broker via a persistent websocket. always listening for known commands and can respond in certain formats like "stats list" or "plaintext". Custom commands can be added per application.

*Security*
AES encryption on JS and Elixir nodes. The websocket broker has no idea what messages / data is being sent over the wire.

*Reason*
No APM right now allows things like "give me a process list". Collecting this across many Elixir Nodes is very cumbersome and can take minutes or longer. This might also be intensive work that you only want to run at your command ,rather than automated.

## Flow

- [x] JS client sends encrypted command (client: [application_name, encrypted_command, command_id]) to client websocket
- [x] Client websocket sends a message to the server channel topic (server:application_id: [command_id, encrypted_command])
- [x] Server websocket listens to the channel topic to broadcast out to the connected socket
- [x] Server channel is processed by each connected server, sends data back over the server channel
- [x] Data received on server channel is sent to client (client: [command_id, encrypted_response, application_name, server_id])

The command_id is randomly generated by the client and acts as an identifier for a request of information throughout the system.

## TODO

- [x] Working end to end flow
- [x] Encryption throughout flow
- [x] JS test flow
- [x] Elixir flow
- [ ] Well defined response formats (graphing, text, etc)
- [ ] Extendable commands
- [ ] Presence to list connected servers per application
- [ ] Run command on a single application node
